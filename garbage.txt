upDown/resume.js/resume

 //basic temporary solution 
    if (!complicated){
        if (x < goalx && y < goaly) {
            x += 10;
            y += 10;
            plane.style.left = x + 'px';
            plane.style.top = y + 'px';
        } else {
            plane.remove();
            clearInterval(timer);
        }
    }

if (x > goalx && y > goaly){
            plane.remove();
            clearInterval(timer);
        } else{ 
            x += 10;
            if((Math.random()*4) < 3)
                y += 10;    
            else 
                y -= 10;
            plane.style.left = x + 'px';
            plane.style.top = y + 'px';
        }

        //plane angles
        let angle = (Math.atan2((y-goaly) / (x-goalx)));
        plane.style.transform = "rotate("+angle+"deg)";

downUp/resume.js/resume

                if (x < goalx && y > goaly) {
                    x += 10;
                    y -= 10;
                    plane.style.left = x + 'px';
                    plane.style.top = y + 'px';
                } else {
                    plane.remove();
                    clearInterval(timer);
                }


flightPath/resume.js/resume

//in charge of finding the flight path
function flightPath(x, y, goalx, goaly){
    let pathLength = goalx*1.5;
    let curLength = 0;
    let stepNum = 0, xmove = 0, ymove = 0;
    let posx =0, posy=0;
    while(pathLength > curLength){
        stepNum++;
        
        if (Math.abs(y+1) >= window.innerHeight/10 || Math.abs(y-1) >= window.innerHeight/10)
            return  myScreen;
        if (Math.abs(y+1) >= (goalx/10) || Math.abs(y-1) >= (goalx/10))
            return   myScreen;
        
        //finds the biggest distance from cur to wall for either x or y
        let dirMax = (goalx - posx) > Math.abs(goaly - posy) ? goalx - posx: goaly -posy;
        if(pathLength - curLength > dirMax){
            while(pathLength > curLength){
                //checks if the plane is within one of the wall
                //had to check a second time due to nested while loops
                if (Math.abs(y+1) >= window.innerHeight/10 || Math.abs(y-1) >= window.innerHeight/10)
                    return   myScreen;
                if (Math.abs(y+1) >= (goalx/10) || Math.abs(y-1) >= (goalx/10))
                    return   myScreen;
                
                //takes you on the straightest path you can to the goal location
                if(y < goaly){
                     myScreen[posy+1][posx+1] = stepNum +1;
                } else if (y > goaly){
                     myScreen[posy-1][posx+1] = stepNum + 1;
                } else {
                     myScreen[posy][posx+1] = stepNum + 1;
                }
                
                //always update these guys, or everything breaks and infinite loops
                curLength = stepNum*10;
                stepNum++;
            }
        }

        // basic movement logic
        xmove = Math.floor(Math.random()*3 - 1);
        ymove = Math.floor(Math.random()*3 - 1);
        posx = posx + xmove;
        posy = posy + ymove;
        if(myScreen.length < posy && posy >=0 && myScreen[0].length < posx && 0 <= posx){
            if (myScreen[posy][posx] == 0)
                myScreen[posy][posx] = stepNum;
            curLength = stepNum*10;
        }  
    }
    return  myScreen;
}



---------------------------------------------------------------11/7/25
function create2DArray(rows, cols) {
    const arr = new Array(Math.floor(rows));
    for (let i = 0; i < rows; i++) {
        arr[i] = new Array(Math.floor(cols)).fill(0);
    }
    return arr;
}

//this method will fill the array 
function flightPath(goalx, goaly){
    let pathLength = goalx * 1.5;
    let curLength = 0;
    let stepNum = 0, xmove = 0, ymove = 0;
    let posx = Math.floor(x / 10), posy = Math.floor(y / 10);

    while(pathLength > curLength){
        stepNum++;

        //checks if the plane is within one of the wall , 
        // will have ot add a "fly off  myScreen" clause when I actually do the flight 
        if (posy < 0 || posy >= myScreen.length) return myScreen;
        if (posx < 0 || posx >= myScreen[0].length) return myScreen;

        // straightest path
        // use posy vs. goal (scaled down to grid) instead of y vs. goaly (pixels)
        if (posy < Math.floor(goaly / 10)){
            if (posy + 1 < myScreen.length && posx + 1 < myScreen[0].length)
                myScreen[posy + 1][posx + 1] = stepNum;
        } else if (posy > Math.floor(goaly / 10)){
            if (posy - 1 >= 0 && posx + 1 < myScreen[0].length)
                myScreen[posy - 1][posx + 1] = stepNum;
        } else {
            if (posy >= 0 && posx + 1 < myScreen[0].length)
                myScreen[posy][posx + 1] = stepNum;
        }

        // random wiggle room
        // basic movement logic
        xmove = Math.floor(Math.random() * 3 - 1);
        ymove = Math.floor(Math.random() * 3 - 1);
        posx = posx + xmove;
        posy = posy + ymove;

        if (posy >= 0 && posy < myScreen.length &&
            posx >= 0 && posx < myScreen[0].length) {
            if (myScreen[posy][posx] == 0)
                myScreen[posy][posx] = stepNum;
        }

        curLength = stepNum * 10;
    }
    return myScreen;
}


// for(let row = -1; row < 2; row++){
        //     for(let col = -1; col < 2; col++){
        //         if (screeny + row >= 0 &&
        //             screeny + row <  myScreen.length &&
        //             screenx + col >= 0 &&
        //             screenx + col <  myScreen[0].length){
        //             if (myScreen[screeny + row][screenx + col] != 0){ 
        //                 y += row*10;
        //                 x += col*10;
        //                 // plane.style.top = y + "px";
        //                 // plane.style.left = x + "px";
        //                 // screeny += row;
        //                 // screenx += col;
        //                 // myScreen[screeny][screenx] = 0;
        //                 moveMade = true;
        //                 break;
        //             }

        //         }
        //     }//screeny + (row) >= 0 && screenx + (col) >= 0 &&
        //     //screenx + (col) <  myScreen[0].length && screeny + (row) <  myScreen.length)
        // }